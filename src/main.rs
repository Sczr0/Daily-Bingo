use serde::{Serialize, Deserialize};
use image::{ImageBuffer, Rgb};
use imageproc::drawing::{draw_text_mut, draw_line_segment_mut};
use rusttype::{Font, Scale};
use chrono::Local;
use rand::{seq::SliceRandom, Rng};
use log::{info, warn, debug};
use std::{fs, path::Path, time::Instant};
use chrono::{Utc, DateTime};
use chrono_tz::Asia::Shanghai;

// ----------------------------- Êï∞ÊçÆÁªìÊûÑÂÆö‰πâ -----------------------------
#[derive(Debug, Clone, Copy, PartialEq, Serialize, Deserialize)]
enum Color {
    Red,
    Blue,
    Black,
    Green,
    Yellow,
    Purple,
    White,
    Orange,
    Cyan,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
struct Cell {
    x: usize,
    y: usize,
    color: Color,
    checked: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
struct Grid(Vec<Vec<Cell>>);

// ----------------------------- ËßÑÂàôÊ†°È™åÂÆûÁé∞ -----------------------------
impl Grid {
    fn get_neighbors(&self, x: usize, y: usize) -> Vec<(usize, usize)> {
        let mut neighbors = Vec::new();
        for i in x.saturating_sub(1)..=x.saturating_add(1) {
            for j in y.saturating_sub(1)..=y.saturating_add(1) {
                if i == x && j == y {
                    continue;
                }
                if i < 5 && j < 5 {
                    neighbors.push((i, j));
                }
            }
        }
        neighbors
    }

    fn get_four_neighbors(&self, x: usize, y: usize) -> Vec<(usize, usize)> {
        let mut neighbors = Vec::new();
        // ‰∏ä
        if x > 0 {
            neighbors.push((x - 1, y));
        }
        // ‰∏ã
        if x < 4 {
            neighbors.push((x + 1, y));
        }
        // Â∑¶
        if y > 0 {
            neighbors.push((x, y - 1));
        }
        // Âè≥
        if y < 4 {
            neighbors.push((x, y + 1));
        }
        neighbors
    }

    fn check_red_rule(&self, x: usize, y: usize) -> bool {
        let neighbors = self.get_neighbors(x, y);
        let ok = neighbors.iter().any(|(i, j)| self.0[*i][*j].checked);
        if !ok {
            debug!("‚ùå Á∫¢Ê†º({},{})ËßÑÂàô‰∏çÊª°Ë∂≥", x, y);
        }
        ok
    }

    fn check_blue_rule(&self, x: usize, y: usize) -> bool {
        let neighbors = self.get_neighbors(x, y);
        let ok = neighbors.iter().filter(|(i, j)| self.0[*i][*j].checked).count() <= 2;
        if !ok {
            debug!("‚ùå ËìùÊ†º({},{})ËßÑÂàô‰∏çÊª°Ë∂≥", x, y);
        }
        ok
    }

    fn check_green_rule(&self, x: usize, y: usize) -> bool {
        let row_count = self.0[x].iter().filter(|cell| cell.checked).count();
        let col_count = (0..5).filter(|i| self.0[*i][y].checked).count();
        let ok = row_count == col_count;
        if !ok {
            debug!("‚ùå ÁªøÊ†º({},{})ËßÑÂàô‰∏çÊª°Ë∂≥", x, y);
        }
        ok
    }

    fn check_yellow_rule(&self, x: usize, y: usize) -> bool {
        let diag1 = self.get_diagonal(x, y, (-1, -1), (1, 1));
        let diag2 = self.get_diagonal(x, y, (-1, 1), (1, -1));

        let count1 = diag1.iter().filter(|&&(i, j)| self.0[i][j].checked).count();
        let count2 = diag2.iter().filter(|&&(i, j)| self.0[i][j].checked).count();

        let ok = count1 == count2;
        if !ok {
            debug!("‚ùå ÈªÑÊ†º({},{})ËßÑÂàô‰∏çÊª°Ë∂≥ÔºöÂØπËßí1ÂãæÊï∞={} ÂØπËßí2ÂãæÊï∞={}", x, y, count1, count2);
        }
        ok
    }

    fn get_diagonal(&self, x: usize, y: usize, dir1: (i32, i32), dir2: (i32, i32)) -> Vec<(usize, usize)> {
        let mut cells = Vec::new();
        let x = x as i32;
        let y = y as i32;

        // Âêëdir1ÊñπÂêëÂª∂‰º∏
        let (mut cx, mut cy) = (x as i32, y as i32);
        loop {
            if cx < 0 || cy < 0 || cx >= 5 || cy >= 5 { break; }
            cells.push((cx as usize, cy as usize));
            cx += dir1.0;
            cy += dir1.1;
        }

        // Âêëdir2ÊñπÂêëÂª∂‰º∏ÔºàË∑≥Ëøá‰∏≠ÂøÉÁÇπÔºâ
        let (mut cx, mut cy) = (x as i32, y as i32);
        loop {
            if cx < 0 || cy < 0 || cx >= 5 || cy >= 5 { break; }
            cells.push((cx as usize, cy as usize));
            cx += dir2.0;
            cy += dir2.1;
        }

        cells
    }

    fn check_purple_rule(&self, x: usize, y: usize) -> bool {
        let neighbors = self.get_neighbors(x, y);
        let ok = neighbors.iter().filter(|(i, j)| self.0[*i][*j].checked).count() % 2 == 1;
        if !ok {
            debug!("‚ùå Á¥´Ê†º({},{})ËßÑÂàô‰∏çÊª°Ë∂≥", x, y);
        }
        ok
    }

    fn check_orange_rule(&self, x: usize, y: usize) -> bool {
        let neighbors = self.get_neighbors(x, y);
        let count = neighbors.iter().filter(|(i, j)| self.0[*i][*j].checked).count();
        let ok = count % 2 == 0;
        if !ok {
            debug!("‚ùå Ê©ôÊ†º({},{})ËßÑÂàô‰∏çÊª°Ë∂≥ÔºöÂë®Âõ¥ÂãæÈÄâÊï∞{}‰∏çÊòØÂÅ∂Êï∞", x, y, count);
        }
        ok
    }

    fn check_cyan_rule(&self, x: usize, y: usize) -> bool {
        let cell = &self.0[x][y];
        if !cell.checked {
            return true;
        }
        let neighbors = self.get_four_neighbors(x, y);
        let has_checked = neighbors.iter().any(|(i, j)| self.0[*i][*j].checked);
        if !has_checked {
            debug!("‚ùå ÈùíÊ†º({},{})ÂãæÈÄâÊó∂Âë®Âõ¥‰∏ä‰∏ãÂ∑¶Âè≥Êó†ÂãæÈÄâÊ†ºÂ≠ê", x, y);
        }
        has_checked
    }

    fn check_all_rules(&self) -> bool {
        for i in 0..5 {
            for j in 0..5 {
                let cell = &self.0[i][j];
                let valid = match cell.color {
                    Color::Red => self.check_red_rule(i, j),
                    Color::Blue => self.check_blue_rule(i, j),
                    Color::Green => self.check_green_rule(i, j),
                    Color::Yellow => self.check_yellow_rule(i, j),
                    Color::Purple => self.check_purple_rule(i, j),
                    Color::Orange => self.check_orange_rule(i, j),
                    Color::Cyan => self.check_cyan_rule(i, j),
                    _ => true,
                };
                if !valid {
                    return false;
                }
            }
        }
        true
    }

    fn check_total_checked(&self, max_checked: usize) -> bool {
        let total = self.0.iter().flatten().filter(|cell| cell.checked).count();
        if total > max_checked {
            debug!("‚ùå ÊÄªÂãæÈÄâÊï∞Ë∂ÖËøáÈôêÂà∂: {} > {}", total, max_checked);
        }
        total <= max_checked
    }

    fn has_five_in_a_row(&self) -> bool {
        // Ê£ÄÊü•Ë°å
        for row in &self.0 {
            for i in 0..=0 {
                if row[i..i+5].iter().all(|cell| cell.checked) {
                    return true;
                }
            }
        }
        // Ê£ÄÊü•Âàó
        for j in 0..5 {
            for i in 0..=0 {
                if (i..i+5).all(|k| self.0[k][j].checked) {
                    return true;
                }
            }
        }
        // Ê£ÄÊü•ÂØπËßíÁ∫ø
        for i in 0..=0 {
            for j in 0..=0 {
                if (0..5).all(|k| self.0[i + k][j + k].checked) 
                || (0..5).all(|k| self.0[i + k][4 - j - k].checked) {
                    return true;
                }
            }
        }
        false
    }

    fn new_blank(color_grid: &[Vec<Color>]) -> Self {
        Grid(
            (0..5).map(|i| {
                (0..5).map(|j| Cell {
                    x: i, y: j,
                    color: color_grid[i][j],
                    checked: false,
                }).collect()
            }).collect()
        )
    }
}

// ----------------------------- Ê±ÇËß£Âô®ÂÆûÁé∞ -----------------------------
struct Solver {
    color_grid: Vec<Vec<Color>>,
    max_checked: usize,
}

impl Solver {
    fn new(color_grid: Vec<Vec<Color>>, max_checked: usize) -> Self {
        Self { color_grid, max_checked }
    }

    fn initialize_grid(&self) -> Grid {
        Grid(
            (0..5).map(|i| {
                (0..5).map(|j| Cell {
                    x: i,
                    y: j,
                    color: self.color_grid[i][j],
                    checked: self.color_grid[i][j] == Color::Black, // ÈªëÊ†ºÈªòËÆ§ÂãæÈÄâ
                }).collect()
            }).collect()
        )
    }

    fn next_position(&self, x: usize, y: usize) -> (usize, usize) {
        if y == 4 { (x + 1, 0) } else { (x, y + 1) }
    }

    fn solve(&self) -> Vec<Grid> {
        let mut solutions = Vec::new();
        let mut current_grid = self.initialize_grid();
        let initial_checked = current_grid.0.iter().flatten().filter(|c| c.checked).count();
        self.backtrack(0, 0, &mut current_grid, &mut solutions, initial_checked);
        solutions
    }

    fn backtrack(&self, x: usize, y: usize, grid: &mut Grid, solutions: &mut Vec<Grid>, current_checked: usize) {
        if x == 5 {
            if grid.check_all_rules() 
                && grid.has_five_in_a_row() 
                && current_checked <= self.max_checked 
            {
                if !solutions.iter().any(|s| s.0 == grid.0) {
                    info!("üéâ ÊâæÂà∞ÊúâÊïàËß£ÔºÅÊÄªÂãæÈÄâÊï∞: {}", current_checked);
                    solutions.push(grid.clone());
                }
            }
            return;
        }
    
        let (next_x, next_y) = self.next_position(x, y);
        
        if self.color_grid[x][y] == Color::Black {
            self.backtrack(next_x, next_y, grid, solutions, current_checked);
        } else {
            // Â∞ùËØïÂãæÈÄâËØ•ÂçïÂÖÉÊ†º
            grid.0[x][y].checked = true;
            let new_checked = current_checked + 1;
            
            // ‰ªÖ‰øùÁïôÊÄªÂãæÈÄâÊï∞Ââ™Êûù
            if new_checked <= self.max_checked {
                self.backtrack(next_x, next_y, grid, solutions, new_checked);
            }
            
            // ÂõûÊ∫ØÔºåÂ∞ùËØï‰∏çÂãæÈÄâ
            grid.0[x][y].checked = false;
            self.backtrack(next_x, next_y, grid, solutions, current_checked);
        }
    }
}

// ----------------------------- ËæìÂá∫ÂáΩÊï∞ -----------------------------
fn save_solutions_json(solutions: &[Grid], path: &str) {
    let data = serde_json::json!({
        "solutions": solutions,
        "total_solutions": solutions.len(),
    });
    fs::create_dir_all(Path::new(path).parent().unwrap()).unwrap();
    fs::write(path, data.to_string()).unwrap();
}

fn save_grid_image(grid: &Grid, path: &str, show_checks: bool, date: &str, solutions_count: usize) {
    // ----------------------------- ÂèÇÊï∞ÈÖçÁΩÆ -----------------------------
    let cell_size: u32 = 90;        // ÂçïÂÖÉÊ†ºÂ∞∫ÂØ∏
    let rule_font_size: f32 = 13.5; // ËßÑÂàôÊñáÂ≠óÂ≠óÂè∑
    let line_spacing: u32 = 22;     // Ë°åÈó¥Ë∑ù
    let margin: u32 = 12;           // ÂÖ®Â±ÄËæπË∑ù
    let rule_column_width: u32 = 310; // ËßÑÂàôÊ†èÂÆΩÂ∫¶

    // ----------------------------- È¢úËâ≤ÂÆö‰πâ -----------------------------
    let background_color = Rgb([245u8, 245u8, 245u8]); // ÊµÖÁÅ∞ËÉåÊôØ
    let rule_bg_color = Rgb([255u8, 255u8, 255u8]);    // ËßÑÂàôÂå∫ÁôΩËâ≤ËÉåÊôØ
    let text_color = Rgb([80u8, 80u8, 80u8]);          // Ê∑±ÁÅ∞ÊñáÂ≠ó
    let grid_line_color = Rgb([210u8, 210u8, 210u8]);  // ÁΩëÊ†ºÁ∫øÈ¢úËâ≤
    let check_color = Rgb([100u8, 100u8, 100u8]);      // ÂãæÈÄâÊ†áËÆ∞È¢úËâ≤

    // ----------------------------- Â∏ÉÂ±ÄËÆ°ÁÆó -----------------------------
    // ËßÑÂàôÊñáÊú¨
    let solution_count_str = format!("Êú¨Êó•È¢òÁõÆÂÖ±Êúâ {} ‰∏™Ëß£", solutions_count); // Â∞Ü format! ÁªìÊûúÂ≠òÂÇ®‰∏∫Â±ÄÈÉ®ÂèòÈáè
    let rules = vec![
        " ",
        " ",
        "Á∫¢Ê†ºÂë®Âõ¥Ëá≥Â∞ëÊúâ‰∏Ä‰∏™Ë¢´ÂãæÈÄâÁöÑÊ†ºÂ≠ê„ÄÇ",
        "ËìùÊ†ºÂë®Âõ¥ÂãæÈÄâÁöÑÊ†ºÂ≠ê‰∏çÂæóË∂ÖËøá‰∏§‰∏™„ÄÇ",
        "ÁªøÊ†ºÊâÄÂú®Ë°åÁöÑÂãæÈÄâÊÄªÊï∞",
        "È°ªÁ≠â‰∫éÊâÄÂú®ÂàóÁöÑÂãæÈÄâÊÄªÊï∞„ÄÇ",
        "ÈªÑÊ†ºÊâÄÂú®‰∏§Êù°‰∫§ÂèâÂØπËßíÁ∫ø",
        "Ôºà‰ªéÈªÑÊ†ºÂêëÂõõËßíÂª∂‰º∏ÔºâÁöÑÂãæÈÄâÊÄªÊï∞ÂøÖÈ°ªÁõ∏Á≠â„ÄÇ",
        "Á¥´Ê†ºÂë®Âõ¥Ë¢´ÂãæÈÄâÁöÑÊ†ºÂ≠êÊï∞ÈáèÈ°ª‰∏∫Â•áÊï∞„ÄÇ",
        "Ê©ôÊ†ºÂë®Âõ¥ÂãæÈÄâÁöÑÊ†ºÂ≠êÊï∞ÈáèÈ°ª‰∏∫ÂÅ∂Êï∞„ÄÇ",
        "ÈùíÊ†ºÂ¶ÇÊûúË¢´ÂãæÈÄâÔºåÂàôÂÖ∂‰∏ä‰∏ãÂ∑¶Âè≥Ôºà‰∏çÂåÖÊã¨ÂØπËßíÔºâ",
        "Ëá≥Â∞ëÊúâ‰∏Ä‰∏™Ë¢´ÂãæÈÄâÁöÑÊ†ºÂ≠ê„ÄÇ",
        "ÈªëÊ†ºÂøÖÈ°ªÂãæ„ÄÇ",
        "ÊØè‰∏™Ê†ºÂ≠êÁöÑÈ¢úËâ≤ËßÑÂàôÂùáÈúÄÊª°Ë∂≥",
        "ÊúÄÁªàË¶ÅÊää‰∫î‰∏™ÂãæËøûËµ∑Êù•ÔºåÂä†Ê≤πÂêß~",
        "-----------------------------------",
        "Âë®Âõ¥ÊåáÁöÑÊòØ‰∏ÄÂúàÂÖ´‰∏™Ê†ºÂ≠êÔºå‰∏çÂåÖÊã¨Ëá™Â∑±",
        "‰∫îËøûÈí©ÂèØ‰ª•ÊòØÊ®™ÊéíÁ´ñÊéíÔºå‰ª•Âèä‰∏§Êù°ÂØπËßíÁ∫ø",
        &solution_count_str, // ‰ΩøÁî®Â±ÄÈÉ®ÂèòÈáèÁöÑÂºïÁî®
    ];

    // Âä†ËΩΩÂ≠ó‰Ωì
    let font_data: &[u8] = include_bytes!("../fonts/font.ttf");
    let font = Font::try_from_bytes(font_data).unwrap();

    // ----------------------------- ÂõæÂÉèÂ∞∫ÂØ∏ËÆ°ÁÆó -----------------------------
    // ËÆ°ÁÆóËßÑÂàôÊñáÊú¨È´òÂ∫¶
    let mut text_height = margin;
    let scale = Scale::uniform(rule_font_size);
    for line in &rules {
        let line_count = line.chars().filter(|c| *c == '\n').count() + 1;
        text_height += line_count as u32 * line_spacing;
    }

    // ÁΩëÊ†ºÂå∫ÂüüÂèÇÊï∞
    let grid_area_height = 5 * cell_size + margin * 2;
    let footer_height = 30; // ÁâàÊùÉ‰ø°ÊÅØÂå∫ÂüüÈ´òÂ∫¶
    
    // ÊÄªÂõæÂÉèÂ∞∫ÂØ∏
    let img_width = rule_column_width + 5 * cell_size + margin * 3;
    let img_height = text_height.max(grid_area_height) + footer_height;

    // ----------------------------- ÁªòÂà∂ÂõæÂÉè -----------------------------
    let mut img = ImageBuffer::from_pixel(img_width, img_height, background_color);

    // ÁªòÂà∂ËßÑÂàôÂå∫ËÉåÊôØ
    for x in 0..rule_column_width {
        for y in 0..img_height {
            img.put_pixel(x, y, rule_bg_color);
        }
    }

    // ÁªòÂà∂ËßÑÂàôÊñáÊú¨
    let mut y_pos = margin as i32;
    for line in rules {
        draw_text_mut(
            &mut img,
            text_color,
            margin as i32 + 10,
            y_pos,
            scale,
            &font,
            line,
        );
        y_pos += line_spacing as i32 * (line.matches('\n').count() as i32 + 1);
    }

    // ÁªòÂà∂ÁΩëÊ†ºÂå∫Âüü
    let grid_start_x = rule_column_width + margin;
    let grid_start_y = (img_height - grid_area_height) / 2; // ÂûÇÁõ¥Â±Ö‰∏≠
    for (i, row) in grid.0.iter().enumerate() {
        for (j, cell) in row.iter().enumerate() {
            // ÂçïÂÖÉÊ†ºÈ¢úËâ≤
            let color = match cell.color {
                Color::Red => [255, 50, 50],
                Color::Blue => [70, 130, 180],
                Color::Black => [40, 40, 40],
                Color::Green => [50, 205, 50],
                Color::Yellow => [255, 215, 0],
                Color::Purple => [128, 0, 128],
                Color::White => [255, 255, 255],
                Color::Orange => [255, 165, 0],
                Color::Cyan => [0, 255, 255],
            };

            // ÂçïÂÖÉÊ†ºÂùêÊ†á
            let x = grid_start_x + j as u32 * cell_size;
            let y = grid_start_y + i as u32 * cell_size;

            // ÁªòÂà∂ÂçïÂÖÉÊ†ºËÉåÊôØ
            for dx in 0..cell_size {
                for dy in 0..cell_size {
                    img.put_pixel(x + dx, y + dy, Rgb(color));
                }
            }

            // ÁªòÂà∂ÂçïÂÖÉÊ†ºËæπÊ°Ü
            for dx in 0..cell_size {
                img.put_pixel(x + dx, y, grid_line_color); // ‰∏äËæπÊ°Ü
                img.put_pixel(x + dx, y + cell_size - 1, grid_line_color); // ‰∏ãËæπÊ°Ü
            }
            for dy in 0..cell_size {
                img.put_pixel(x, y + dy, grid_line_color); // Â∑¶ËæπÊ°Ü
                img.put_pixel(x + cell_size - 1, y + dy, grid_line_color); // Âè≥ËæπÊ°Ü
            }

            // ÁªòÂà∂ÂãæÈÄâÊ†áËÆ∞
            if show_checks && cell.checked {
                draw_line_segment_mut(
                    &mut img,
                    (x as f32 + 10.0, y as f32 + 10.0),
                    (x as f32 + cell_size as f32 - 10.0, y as f32 + cell_size as f32 - 10.0),
                    check_color,
                );
                draw_line_segment_mut(
                    &mut img,
                    (x as f32 + 10.0, y as f32 + cell_size as f32 - 10.0),
                    (x as f32 + cell_size as f32 - 10.0, y as f32 + 10.0),
                    check_color,
                );
            }
        }
    }

    // ----------------------------- ÁâàÊùÉ‰ø°ÊÅØ -----------------------------
    let footer = format!("Generated by BingoSolver @ {}", date);
    let footer_scale = Scale::uniform(12.0);
    draw_text_mut(
        &mut img,
        text_color,
        margin as i32 + 10, // ‰∏éËßÑÂàôÊñáÂ≠óÂ∑¶ÂØπÈΩê
        (img_height - footer_height + 8) as i32, // ‰øùÊåÅÂú®Âêå‰∏ÄÈ´òÂ∫¶
        footer_scale,
        &font,
        &footer
    );

    img.save(path).unwrap();
}

fn move_to_date_folder(date: &str) {
    let date_folder = format!("data/{}", date);
    if Path::new(&date_folder).exists() {
        fs::remove_dir_all(&date_folder).unwrap();
    }
    fs::create_dir_all(&date_folder).unwrap();

    // ÈúÄË¶Å‰øùÁïôÂú®Ê†πÁõÆÂΩïÁöÑÊñá‰ª∂Âêç
    let keep_files = vec!["solutions.json", "blank.png"];

    for entry in fs::read_dir("data").unwrap() {
        let entry = entry.unwrap();
        let path = entry.path();

        // ‰ªÖÂ§ÑÁêÜÊñá‰ª∂ÔºåË∑≥ËøáÁõÆÂΩï
        if !path.is_file() {
            continue;
        }

        let file_name = entry.file_name();
        let file_name_str = file_name.to_str().unwrap();

        // ‰ªÖÁßªÂä®Èùû‰øùÁïôÊñá‰ª∂Ôºà‰∏î‰∏çÊòØÂΩìÂâçÊó•ÊúüÁöÑÊñá‰ª∂Â§πÔºâ
        if !keep_files.contains(&file_name_str) && file_name_str != date {
            let new_path = format!("{}/{}", date_folder, file_name_str);
            fs::rename(&path, new_path).unwrap();
        }
    }
}

// ----------------------------- ‰∏ªÂáΩÊï∞ -----------------------------
fn main() {
    env_logger::Builder::from_default_env()
        .format_timestamp_millis()
        .format_module_path(false)
        .filter_level(log::LevelFilter::Info)
        .init();
    info!("Á®ãÂ∫èÂêØÂä®");

    fs::create_dir_all("data").expect("Êó†Ê≥ïÂàõÂª∫dataÁõÆÂΩï");

    let (solutions, date, color_grid) = loop {
        let utc_time = Utc::now();
        let beijing_time: DateTime<chrono_tz::Tz> = utc_time.with_timezone(&Shanghai);
        let date = beijing_time.format("%Y-%m-%d").to_string();
        
        // ÁîüÊàêÊñ∞ÁöÑÈ¢úËâ≤ÁΩëÊ†º
        let color_grid = generate_color_grid();
        info!("ÁîüÊàêÊñ∞È¢òÁõÆÂ∏ÉÂ±Ä:\n{}", format_grid_colors(&color_grid));

        let solver = Solver::new(color_grid.clone(), 25);
        let solutions = solver.solve();
        
        if !solutions.is_empty() {
            break (solutions, date, color_grid);
        }
        warn!("Êú™ÊâæÂà∞Ëß£ÔºåÈáçÊñ∞ÁîüÊàêÈ¢òÁõÆ...");
    };

    // ‰øùÂ≠òÂà∞Ê†πÁõÆÂΩï
    save_solutions_json(&solutions, "data/solutions.json");
    save_grid_image(
        &Grid::new_blank(&color_grid), 
        "data/blank.png", 
        false, 
        &date,
        solutions.len() // ‰º†ÈÄíËß£Êï∞Èáè
    );

    // ‰øùÂ≠òÂà∞Êó•ÊúüÊñá‰ª∂Â§π
    move_to_date_folder(&date);
    save_solutions_json(&solutions, &format!("data/{}/solutions.json", date));
    for (i, solution) in solutions.iter().enumerate() {
        save_grid_image(
            solution, 
            &format!("data/{}/solution_{}.png", date, i), 
            true, 
            &date,
            solutions.len() // ‰º†ÈÄíËß£Êï∞Èáè
        );
    }
    save_grid_image(
        &Grid::new_blank(&color_grid), 
        &format!("data/{}/blank.png", date), 
        false, 
        &date,
        solutions.len()
    );

    info!("ÁªìÊûúÂ∑≤‰øùÂ≠òËá≥ data/ Âíå data/{}/ Êñá‰ª∂Â§π", date);
}

// ----------------------------- Â∑•ÂÖ∑ÂáΩÊï∞ -----------------------------
fn generate_color_grid() -> Vec<Vec<Color>> {
    let mut rng = rand::thread_rng();
    let colors = vec![
        Color::Red, Color::Blue, Color::Black,
        Color::Green, Color::Yellow, Color::Purple, 
        Color::White, Color::Orange, Color::Cyan,
    ];
    
    // ÁîüÊàêÂàùÂßãÈöèÊú∫ÁΩëÊ†º
    let mut grid: Vec<Vec<Color>> = (0..5)
        .map(|_| (0..5).map(|_| *colors.choose(&mut rng).unwrap()).collect())
        .collect();

    // Âº∫Âà∂Ëá≥Â∞ëÊúâ10‰∏™ÁôΩÊ†º
    let mut white_count = grid.iter().flatten().filter(|c| **c == Color::White).count();
    while white_count < 10 {
        let x = rng.gen_range(0..5);
        let y = rng.gen_range(0..5);
        if grid[x][y] != Color::White {
            grid[x][y] = Color::White;
            white_count += 1;
        }
    }

    grid
}

fn format_grid_colors(grid: &[Vec<Color>]) -> String {
    grid.iter().map(|row| {
        row.iter().map(|color| match color {
            Color::Red => "Á∫¢",
            Color::Blue => "Ëìù",
            Color::Black => "Èªë",
            Color::Green => "Áªø",
            Color::Yellow => "ÈªÑ",
            Color::Purple => "Á¥´",
            Color::White => "ÁôΩ",
            Color::Orange => "Ê©ô",
            Color::Cyan => "Èùí",
        }).collect::<Vec<_>>().join(" ")
    }).collect::<Vec<_>>().join("\n")
}